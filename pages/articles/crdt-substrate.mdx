import RunnableCode from "@/components/RunnableCode";
import { Callout } from "nextra-theme-docs";
import Nodes from "@/components/crdt-substrate/Nodes";

# CRDT Substrate

What if I told you anyone can create a new CRDT? That with no special knowledge, you can write a set of mutations that can be applied to a data structure in a way that is guaranteed to converge? That you can do this without any locks, mutexes, or other concurrency primitives? That you can do this without any special knowledge of distributed systems?

<br/>

<center>
![meme](/blog/crdt-substrate/told-you.jpg)
</center>

Nobody can be told this truth. They must see it for themselves.

## Seeing is Believing

We'll start with some initial state --

<RunnableCode code={`const state = {
  counter: 0,
  items: []
};

provide state;`} />

And then let you author _any mutation you want_ against that state. The only rule is that your mutations must be deterministic. Some example mutations have been provided for you below.

<RunnableCode code={`// Mutations are just functions that modify the current state.
// The first arg must always be \`state\`.
// Any additional args are parameters for the mutation.
const mutations = {
  increment(state) {
    state.counter++;
  },
  addItem(state, item) {
    state.items.push(item);
  },

  // We'll discuss these two mutations in detail later.
  moveItem(state, fromIndex, toIndex) {
    const arr = state.items;
    if (fromIndex < 0 || toIndex < 0 || fromIndex > arr.length || toIndex > arr.length
    ) {
      return false;
    }
    const element = arr[fromIndex];
    arr.splice(fromIndex, 1);
    arr.splice(toIndex, 0, element);
  },
  popItem(state) {
    if (state.items.length > 0) {
      state.items.pop();
    } else {
      return false;
    }
  }
};

provide mutations;`} />

<Callout type="info">
After making any changes to the code, press `shift + enter` or the `play` button (top right of the code box) to re-run the code and update the example.
</Callout>

Now lets see this in action.

Below are three independent UIs that are driven by three indepent copies of the initial state. On each node you can run your mutations. Whenever you desire, have the nodes merge their state together with the "sync state" button.

<br/>
<Nodes />

Pretty cool, right? All of the nodes converge to the same state and you didn't have to write any special code to make this happen. You just wrote some mutations and the substrate took care of the rest.

If you were paying close attention, however, you'll notice that some user intent was not preserved. So while yes, you can create a CRDT without any special knowledge, you can't create a CRDT that preserves user intent without some special knowledge.


## Missing Intent

- Fract index & order
- Counter & race (tx isolation levels)
- Pop by index? Or pop by item id?

## Preserving Intent

