import RunnableCode from "@/components/RunnableCode";
import { Callout } from "nextra-theme-docs";
import Nodes from "@/components/crdt-substrate/Nodes";

# CRDT Substrate

What if I told you anyone can create a new CRDT? That with no special knowledge, you can write a set of mutations that can be applied to a data structure in a way that is guaranteed to converge? That you can do this without any locks, mutexes, or other concurrency primitives? That you can do this without any special knowledge of distributed systems?

<br/>

<center>
![meme](/blog/crdt-substrate/told-you.jpg)
</center>

Nobody can be told this truth. They must see it for themselves.

## Seeing is Believing

We'll start with some initial state --

<RunnableCode code={`const state = {
  counter: 0,
  items: []
};

provide state;`} />

And then let you author _any mutation you want_ against that state. The only rule is that your mutations must be deterministic and if the mutation is a no-op it should return false. Some example mutations have been provided for you below.

<RunnableCode code={`// Mutations are just functions that modify the current state.
// The first arg must always be \`state\`.
// Any additional args are parameters for the mutation.
const mutations = {
  increment(state) {
    state.counter++;
  },
  addItem(state, item) {
    state.items.push(item);
  }
};

provide mutations;`} />

<Callout type="info">
After making any changes to the code, press `shift + enter` or the `play` button (top right of the code box) to re-run the code and update the example.
</Callout>

Now lets see this in action.

Below are three independent UIs that are driven by three indepent copies of the initial state. On each node you can run your mutations. Whenever you desire, have the nodes merge their state together with the "sync state" button.

<br/>
<Nodes />

Pretty cool, right? All of the nodes converge to the same state and you didn't have to write any special code to make this happen. You just wrote some mutations and the substrate took care of the rest.

Depending on what examples you ended up writing for yourself, you may have noticed that while everything does converge user intent is not always preserved.

## User Intent

Preserving user intent is about more than all nodes converging to the same state. It's about that final state matching the user's expectations.

To drive this home, we'll look at a delete operation that is based on array index.

```js
function deleteItem(state, index) {
  if (index < 0 || index >= state.items.length) {
    return false;
  }
  state.items.splice(index, 1);
}
```

This mutation is deterministic and it will converge but it doesn't preserve user intent.

A few ways it can fail to preserve user intent:
1. Two users trying to delete the same item will result in _two_ items being removed
2. Say we have a list of letters. Trying to remove "c" could end up removing a completely unrelated letter after merge.

Illustrated:



since the _identity of what to delete_ is given by an index rather than being a property of the elements.

 If two users delete the same item at the same time, _two__ items will be deleted rather than the single item. This is because the index of the item is not stable. If the item is deleted on one node, the index of the item on the other node will change.

If you were paying close attention, however, you'll notice that some user intent was not preserved. So while yes, you can create a CRDT without any special knowledge, you can't create a CRDT that preserves user intent without some special knowledge.


## Missing Intent

- Fract index & order
- Counter & race (tx isolation levels)
- Pop by index? Or pop by item id?

## Preserving Intent

## Substrate - Implementation