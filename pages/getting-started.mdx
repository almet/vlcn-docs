# Getting Started

Vulcan is split into a few components:

1. Conflict-free database
2. Platform Integrations
3. Networking
4. Live query engine

## CR-SQLite

`CR-SQLite` is a SQLite extension that allow sqlite databases to be merged together. This extension can be used independently of all other Vulcan components and loaded into existing SQLite deployments. The extension can be used from any language that has SQLite bindings.

[Get started with CR-SQLite](./cr-sqlite/intro)

## Platform Integrations

While `cr-sqlite` can run anywhere and provide you with a database that supports merging over a SQL API, platform &language integrations exist to simplify getting started.

- [Get started with JavaScript](./js/wasm)
- [Get started with other languages](./appendix/languages)

## Networking

`cr-sqlite` is network agnostic. You can bring whatever transport you like (protobuffs, trpc, websockets, etc.) so long as you follow a few conventions. All that being said, Vulcan also provides a default networking layer.

[Get started with networking](./networking/background)

## Live Query Engine

To enable applications at scale & extremely time-sensitive interactions, we're building a smart live query (reactive query) engine. This is currently a work in progress but based around the ideas of [segmeent & interval trees](https://stackoverflow.com/questions/17466218/what-are-the-differences-between-segment-trees-interval-trees-binary-indexed-t) and [differential dataflow](https://github.com/TimelyDataflow/differential-dataflow).

The reactive queries available in the React integration are not yet based on this engine. They take a simpler approach of re-running queries when the tables those queries use are updated. We've seen this simple approach work for resolving ~100 concurrent queries in a single frame in the browser but we'd like to do better.

The live query engine will also enable scaling on the server and support multi-tenant use cases.
